schema {
  query: Query
  subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type Account {
  """The account id"""
  id: ID!
  """
  Users that have been granted `ApprovalForAll` token of the User's Collection
  """
  authorizedUsers(skip: Int = 0, first: Int = 100, orderBy: Account_orderBy, orderDirection: OrderDirection, where: Account_filter): [Account!]
  """The Media the User owns"""
  collection(skip: Int = 0, first: Int = 100, orderBy: Token_orderBy, orderDirection: OrderDirection, where: Token_filter): [Token!]!
  """The Media the User created"""
  creations(skip: Int = 0, first: Int = 100, orderBy: Token_orderBy, orderDirection: OrderDirection, where: Token_filter): [Token!]!
  """The transfers from a user"""
  transfersFrom(skip: Int = 0, first: Int = 100, orderBy: Transfer_orderBy, orderDirection: OrderDirection, where: Transfer_filter): [Transfer!]!
  """The transfers to a user"""
  transfersTo(skip: Int = 0, first: Int = 100, orderBy: Transfer_orderBy, orderDirection: OrderDirection, where: Transfer_filter): [Transfer!]!
}

input Account_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  authorizedUsers: [String!]
  authorizedUsers_not: [String!]
  authorizedUsers_contains: [String!]
  authorizedUsers_contains_nocase: [String!]
  authorizedUsers_not_contains: [String!]
  authorizedUsers_not_contains_nocase: [String!]
  authorizedUsers_: Account_filter
  collection_: Token_filter
  creations_: Token_filter
  transfersFrom_: Transfer_filter
  transfersTo_: Transfer_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Account_orderBy {
  id
  authorizedUsers
  collection
  creations
  transfersFrom
  transfersTo
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type Contract {
  """The contract id"""
  id: ID!
  """Supports ERC721 metadata"""
  supportsMetadata: Boolean
  """The token name"""
  name: String
  """The token symbol"""
  symbol: String
  """The maximum amount of available tokens"""
  maxSupply: BigInt
  """The current supply of tokens"""
  totalSupply: BigInt
  """The maximum amount reserved for gifts"""
  maxReserved: BigInt
  """The paused state of the contract"""
  paused: Boolean
  """All tokens of the contract"""
  tokens(skip: Int = 0, first: Int = 100, orderBy: Token_orderBy, orderDirection: OrderDirection, where: Token_filter): [Token!]!
}

input Contract_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  supportsMetadata: Boolean
  supportsMetadata_not: Boolean
  supportsMetadata_in: [Boolean!]
  supportsMetadata_not_in: [Boolean!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  maxSupply: BigInt
  maxSupply_not: BigInt
  maxSupply_gt: BigInt
  maxSupply_lt: BigInt
  maxSupply_gte: BigInt
  maxSupply_lte: BigInt
  maxSupply_in: [BigInt!]
  maxSupply_not_in: [BigInt!]
  totalSupply: BigInt
  totalSupply_not: BigInt
  totalSupply_gt: BigInt
  totalSupply_lt: BigInt
  totalSupply_gte: BigInt
  totalSupply_lte: BigInt
  totalSupply_in: [BigInt!]
  totalSupply_not_in: [BigInt!]
  maxReserved: BigInt
  maxReserved_not: BigInt
  maxReserved_gt: BigInt
  maxReserved_lt: BigInt
  maxReserved_gte: BigInt
  maxReserved_lte: BigInt
  maxReserved_in: [BigInt!]
  maxReserved_not_in: [BigInt!]
  paused: Boolean
  paused_not: Boolean
  paused_in: [Boolean!]
  paused_not_in: [Boolean!]
  tokens_: Token_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Contract_orderBy {
  id
  supportsMetadata
  name
  symbol
  maxSupply
  totalSupply
  maxReserved
  paused
  tokens
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Query {
  token(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  account(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    skip: Int = 0
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    where: Account_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Account!]!
  contract(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Contract
  contracts(
    skip: Int = 0
    first: Int = 100
    orderBy: Contract_orderBy
    orderDirection: OrderDirection
    where: Contract_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Contract!]!
  transfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transfer
  transfers(
    skip: Int = 0
    first: Int = 100
    orderBy: Transfer_orderBy
    orderDirection: OrderDirection
    where: Transfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transfer!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Subscription {
  token(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  account(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    skip: Int = 0
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    where: Account_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Account!]!
  contract(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Contract
  contracts(
    skip: Int = 0
    first: Int = 100
    orderBy: Contract_orderBy
    orderDirection: OrderDirection
    where: Contract_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Contract!]!
  transfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transfer
  transfers(
    skip: Int = 0
    first: Int = 100
    orderBy: Transfer_orderBy
    orderDirection: OrderDirection
    where: Transfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transfer!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Token {
  """The token id"""
  id: ID!
  """The contract the token was created in"""
  contract: Contract!
  """The transaction hash the token was created at"""
  transactionHash: String!
  """The current owner of the token"""
  owner: Account!
  """The creator of the token"""
  creator: Account!
  """The previous owner of the token"""
  prevOwner: Account!
  """The approved user of the token"""
  approved: Account
  """The uri of the image"""
  imageURI: String!
  """The uri of the metadata"""
  metadataURI: String!
  """The timestamp of the block the token was minted in"""
  createdAtTimestamp: BigInt!
  """The number of the block the token was minted in"""
  createdAtBlockNumber: BigInt!
  """The transfers of the Media"""
  transfers(skip: Int = 0, first: Int = 100, orderBy: Transfer_orderBy, orderDirection: OrderDirection, where: Transfer_filter): [Transfer!]
}

input Token_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  contract: String
  contract_not: String
  contract_gt: String
  contract_lt: String
  contract_gte: String
  contract_lte: String
  contract_in: [String!]
  contract_not_in: [String!]
  contract_contains: String
  contract_contains_nocase: String
  contract_not_contains: String
  contract_not_contains_nocase: String
  contract_starts_with: String
  contract_starts_with_nocase: String
  contract_not_starts_with: String
  contract_not_starts_with_nocase: String
  contract_ends_with: String
  contract_ends_with_nocase: String
  contract_not_ends_with: String
  contract_not_ends_with_nocase: String
  contract_: Contract_filter
  transactionHash: String
  transactionHash_not: String
  transactionHash_gt: String
  transactionHash_lt: String
  transactionHash_gte: String
  transactionHash_lte: String
  transactionHash_in: [String!]
  transactionHash_not_in: [String!]
  transactionHash_contains: String
  transactionHash_contains_nocase: String
  transactionHash_not_contains: String
  transactionHash_not_contains_nocase: String
  transactionHash_starts_with: String
  transactionHash_starts_with_nocase: String
  transactionHash_not_starts_with: String
  transactionHash_not_starts_with_nocase: String
  transactionHash_ends_with: String
  transactionHash_ends_with_nocase: String
  transactionHash_not_ends_with: String
  transactionHash_not_ends_with_nocase: String
  owner: String
  owner_not: String
  owner_gt: String
  owner_lt: String
  owner_gte: String
  owner_lte: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_contains: String
  owner_contains_nocase: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_: Account_filter
  creator: String
  creator_not: String
  creator_gt: String
  creator_lt: String
  creator_gte: String
  creator_lte: String
  creator_in: [String!]
  creator_not_in: [String!]
  creator_contains: String
  creator_contains_nocase: String
  creator_not_contains: String
  creator_not_contains_nocase: String
  creator_starts_with: String
  creator_starts_with_nocase: String
  creator_not_starts_with: String
  creator_not_starts_with_nocase: String
  creator_ends_with: String
  creator_ends_with_nocase: String
  creator_not_ends_with: String
  creator_not_ends_with_nocase: String
  creator_: Account_filter
  prevOwner: String
  prevOwner_not: String
  prevOwner_gt: String
  prevOwner_lt: String
  prevOwner_gte: String
  prevOwner_lte: String
  prevOwner_in: [String!]
  prevOwner_not_in: [String!]
  prevOwner_contains: String
  prevOwner_contains_nocase: String
  prevOwner_not_contains: String
  prevOwner_not_contains_nocase: String
  prevOwner_starts_with: String
  prevOwner_starts_with_nocase: String
  prevOwner_not_starts_with: String
  prevOwner_not_starts_with_nocase: String
  prevOwner_ends_with: String
  prevOwner_ends_with_nocase: String
  prevOwner_not_ends_with: String
  prevOwner_not_ends_with_nocase: String
  prevOwner_: Account_filter
  approved: String
  approved_not: String
  approved_gt: String
  approved_lt: String
  approved_gte: String
  approved_lte: String
  approved_in: [String!]
  approved_not_in: [String!]
  approved_contains: String
  approved_contains_nocase: String
  approved_not_contains: String
  approved_not_contains_nocase: String
  approved_starts_with: String
  approved_starts_with_nocase: String
  approved_not_starts_with: String
  approved_not_starts_with_nocase: String
  approved_ends_with: String
  approved_ends_with_nocase: String
  approved_not_ends_with: String
  approved_not_ends_with_nocase: String
  approved_: Account_filter
  imageURI: String
  imageURI_not: String
  imageURI_gt: String
  imageURI_lt: String
  imageURI_gte: String
  imageURI_lte: String
  imageURI_in: [String!]
  imageURI_not_in: [String!]
  imageURI_contains: String
  imageURI_contains_nocase: String
  imageURI_not_contains: String
  imageURI_not_contains_nocase: String
  imageURI_starts_with: String
  imageURI_starts_with_nocase: String
  imageURI_not_starts_with: String
  imageURI_not_starts_with_nocase: String
  imageURI_ends_with: String
  imageURI_ends_with_nocase: String
  imageURI_not_ends_with: String
  imageURI_not_ends_with_nocase: String
  metadataURI: String
  metadataURI_not: String
  metadataURI_gt: String
  metadataURI_lt: String
  metadataURI_gte: String
  metadataURI_lte: String
  metadataURI_in: [String!]
  metadataURI_not_in: [String!]
  metadataURI_contains: String
  metadataURI_contains_nocase: String
  metadataURI_not_contains: String
  metadataURI_not_contains_nocase: String
  metadataURI_starts_with: String
  metadataURI_starts_with_nocase: String
  metadataURI_not_starts_with: String
  metadataURI_not_starts_with_nocase: String
  metadataURI_ends_with: String
  metadataURI_ends_with_nocase: String
  metadataURI_not_ends_with: String
  metadataURI_not_ends_with_nocase: String
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_not_in: [BigInt!]
  transfers_: Transfer_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Token_orderBy {
  id
  contract
  transactionHash
  owner
  creator
  prevOwner
  approved
  imageURI
  metadataURI
  createdAtTimestamp
  createdAtBlockNumber
  transfers
}

type Transfer {
  """<tokenId>-<transactionHash>-<logIndex>"""
  id: ID!
  """Transaction hash for the transfer"""
  transactionHash: String!
  """The Media associated with the Transfer"""
  token: Token!
  """The User transferring the Media"""
  from: Account!
  """The User receiving the Media"""
  to: Account!
  """The timestamp of the block the Transfer was created in"""
  createdAtTimestamp: BigInt!
  """The number of the block the Transfer was created in"""
  createdAtBlockNumber: BigInt!
  """The gas price for the transaction"""
  gasPrice: BigInt!
  """The price of the transaction"""
  value: BigInt!
}

input Transfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: String
  transactionHash_not: String
  transactionHash_gt: String
  transactionHash_lt: String
  transactionHash_gte: String
  transactionHash_lte: String
  transactionHash_in: [String!]
  transactionHash_not_in: [String!]
  transactionHash_contains: String
  transactionHash_contains_nocase: String
  transactionHash_not_contains: String
  transactionHash_not_contains_nocase: String
  transactionHash_starts_with: String
  transactionHash_starts_with_nocase: String
  transactionHash_not_starts_with: String
  transactionHash_not_starts_with_nocase: String
  transactionHash_ends_with: String
  transactionHash_ends_with_nocase: String
  transactionHash_not_ends_with: String
  transactionHash_not_ends_with_nocase: String
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  from: String
  from_not: String
  from_gt: String
  from_lt: String
  from_gte: String
  from_lte: String
  from_in: [String!]
  from_not_in: [String!]
  from_contains: String
  from_contains_nocase: String
  from_not_contains: String
  from_not_contains_nocase: String
  from_starts_with: String
  from_starts_with_nocase: String
  from_not_starts_with: String
  from_not_starts_with_nocase: String
  from_ends_with: String
  from_ends_with_nocase: String
  from_not_ends_with: String
  from_not_ends_with_nocase: String
  from_: Account_filter
  to: String
  to_not: String
  to_gt: String
  to_lt: String
  to_gte: String
  to_lte: String
  to_in: [String!]
  to_not_in: [String!]
  to_contains: String
  to_contains_nocase: String
  to_not_contains: String
  to_not_contains_nocase: String
  to_starts_with: String
  to_starts_with_nocase: String
  to_not_starts_with: String
  to_not_starts_with_nocase: String
  to_ends_with: String
  to_ends_with_nocase: String
  to_not_ends_with: String
  to_not_ends_with_nocase: String
  to_: Account_filter
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  value: BigInt
  value_not: BigInt
  value_gt: BigInt
  value_lt: BigInt
  value_gte: BigInt
  value_lte: BigInt
  value_in: [BigInt!]
  value_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Transfer_orderBy {
  id
  transactionHash
  token
  from
  to
  createdAtTimestamp
  createdAtBlockNumber
  gasPrice
  value
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}